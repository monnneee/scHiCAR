shell.prefix("set -eo pipefail; echo BEGIN at $(date); ")
shell.suffix("; exitstat=$?; echo END at $(date); echo exit status was $exitstat; exit $exitstat")
import collections

FILES = json.load(open('samples.json')) ##  fastq for each lane
SAMPLES = sorted(FILES.keys())

TARGETS = []
tmp='./tmp'

TARGETS.extend(expand("03_corrected_fq/{sample}_ME_L001_R1_001.fastq.gz",sample = SAMPLES ))
TARGETS.extend(expand("03_corrected_fq/{sample}_ME_L001_R2_001.fastq.gz",sample = SAMPLES ))
TARGETS.extend(expand("03_corrected_fq/{sample}_all_L001_R1_001.fastq.gz",sample = SAMPLES ))
TARGETS.extend(expand("03_corrected_fq/{sample}_all_L001_R2_001.fastq.gz",sample = SAMPLES ))

localrules: targetfiles, read_info_summary
rule targetfiles:
    input: TARGETS

## trim specific sequence in the 5 end of read1
rule cut_specific_sequences:
    input:
        r1 = lambda wildcards: FILES[wildcards.sample]['R1'],
        r2 = lambda wildcards: FILES[wildcards.sample]['R2']
    output: 
        r1 = "01_raw_fq_update/{sample}_adapter_L001_R1_001.fastq",
        r2 = "01_raw_fq_update/{sample}_adapter_L001_R2_001.fastq",
        r3 = "01_raw_fq_update/{sample}_NOadapter_L001_R1_001.fastq",
        r4 = "01_raw_fq_update/{sample}_NOadapter_L001_R2_001.fastq"
    shell:
        """
        cutadapt -j 11 --action=retain  -g  'NNNNNNNNNNNNNNCCATTCCAGCAGCGTGTGCGAACTCAGACCNNNNNNNATCCACGTGCTTGAGAGGCCAGAGCATTCG;min_overlap=82; max_error_rate=0.086;' --minimum-length 124:146  -o {output[0]} -p {output[1]} --untrimmed-output {output[2]} --untrimmed-paired-output {output[3]}  {input[0]} {input[1]}
        """

## extract the barcodes from sequence and append them to the 5' end of read1
rule move_barcode_to_5end_R1:
    input:
        r1 = "01_raw_fq_update/{sample}_adapter_L001_R1_001.fastq"
    output: 
        r1 = "01_raw_fq_update/{sample}_adapter123_umi_L001_R1_001.fastq"
    shell:
        """
        awk  '{{if(NR%2==0) {{print  substr($0,82,6)  substr($0,46,6) substr($0,1,6)  substr($0,7,8) substr($0,length($0)-10+1,10) substr($0,88)}} else  {{print $0 }} }}' {input}  > {output} 
        """

## remove the TSO sequence in the 5 end of read2
rule cut_R2_TSO_sequence:
    input:
        r1 = "01_raw_fq_update/{sample}_adapter123_umi_L001_R1_001.fastq",
        r2 = "01_raw_fq_update/{sample}_adapter_L001_R2_001.fastq"
    output: 
        r1 = temp("01_raw_fq_update/{sample}_cut_tso2_L001_R1_001.fastq.gz"),
        r2 = temp("01_raw_fq_update/{sample}_cut_tso2_L001_R2_001.fastq.gz")
    shell:
        "cutadapt  -e 0.15 --action=trim --minimum-length 27  -G 'XCAGTGGTATCAACGCAGAGTACATGGG;min_overlap=10' -o {output[0]} -p {output[1]} {input[0]} {input[1]}"


## remove the polyA seqence and adaptor sequence in the 3 end of read2
rule cut_R2_polyA_adaptor:
    input:
        r1 = "01_raw_fq_update/{sample}_cut_tso2_L001_R1_001.fastq.gz",
        r2 = "01_raw_fq_update/{sample}_cut_tso2_L001_R2_001.fastq.gz"
    output: 
        r1 = "01_raw_fq_update/{sample}_cut_tso2_polyA_L001_R1_001.fastq",
        r2 = "01_raw_fq_update/{sample}_cut_tso2_polyA_L001_R2_001.fastq",
        r3 = "01_raw_fq_update/{sample}_cut_R2adapter_L001_R1_001.fastq",
        r4 = "01_raw_fq_update/{sample}_cut_R2adapter_L001_R2_001.fastq"
    shell:
        """
        cutadapt -e 0.15 --action=trim --minimum-length 27  -A 'AAAAAAAAAAAAAAAA;min_overlap=14' -o {output[0]} -p {output[1]} {input[0]} {input[1]}
        cutadapt -e 0.15 --action=trim --minimum-length 27  -A 'GCTGTANNNNNNCGAATGCTCTGGCCT;min_overlap=20' -o {output[2]} -p {output[3]} {output[0]} {output[1]}
        """

## split the fastq file into two fastq files: one was generated using oligo_dT primer and the other using random hexamer primer
rule split_fq_with_oligdT_random_hexamer:
    input:
        r1 = "01_raw_fq_update/{sample}_cut_R2adapter_L001_R1_001.fastq",
        r2 = "01_raw_fq_update/{sample}_cut_R2adapter_L001_R2_001.fastq"
    output:
        "01_raw_fq_update/{sample}_adapter1ME_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1ME_L001_R2_001.fastq",
        "01_raw_fq_update/{sample}_adapter1RNA_oligodT_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1RNA_oligodT_L001_R2_001.fastq",
        "01_raw_fq_update/{sample}_adapter1RNA_randomN_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1RNA_randomN_L001_R2_001.fastq"
    shell:
        """
        cutadapt -Z -j {threads} -e 0.2 --action=retain -g file:ME_index --minimum-length 34:27\
        -o 01_raw_fq_update/{wildcards.sample}_adapter1{{name}}_L001_R1_001.fastq \
        -p 01_raw_fq_update/{wildcards.sample}_adapter1{{name}}_L001_R2_001.fastq \
        {input[0]}  {input[1]}
        """

## extract total barcodes list, count each barcode
rule barcode_QC: ## extract total barcodes list
    input: 
        "01_raw_fq_update/{sample}_adapter1RNA_oligodT_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1RNA_randomN_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1ME_L001_R1_001.fastq"

    output: 
        "02_barcode_info/{sample}_oligodT_raw_barcode_count.txt",
        "02_barcode_info/{sample}_randomN_raw_barcode_count.txt",
        "02_barcode_info/{sample}_ME_raw_barcode_count.txt"
    threads: 8 
    shell:
        """
        mkdir ./tmp
        awk  '{{if(NR%4==2) print substr($0,1,18) }}' {input[0]} | sort --parallel={threads} --temporary-directory={tmp}  | uniq -c | sort -nr   > {output[0]} 
        awk  '{{if(NR%4==2) print substr($0,1,18) }}' {input[1]} | sort --parallel={threads} --temporary-directory={tmp}  | uniq -c | sort -nr   > {output[1]}
        awk  '{{if(NR%4==2) print substr($0,1,18) }}' {input[2]} | sort --parallel={threads} --temporary-directory={tmp}  | uniq -c | sort -nr   > {output[2]}
        """

## compare the extracted barcodes with the whitelist
rule compare_barcodes_with_whitelist:
    input: 
        "02_barcode_info/{sample}_oligodT_raw_barcode_count.txt",
    output: sum = "02_barcode_info/{sample}_oligodT.barcode_final_summary",
            map = "02_barcode_info/{sample}_oligodT.barcode_final_map",
            log = "02_barcode_info/{sample}_oligodT.barcode_log"
    script:
        "script/barcode_hash_v2.py"

rule find_right_barcodes_randomN:
    input: 
        "02_barcode_info/{sample}_randomN_raw_barcode_count.txt"
    output: sum = "02_barcode_info/{sample}_randomN.barcode_final_summary",
            map = "02_barcode_info/{sample}_randomN.barcode_final_map",
            log = "02_barcode_info/{sample}_randomN.barcode_log"
    script:
        "script/barcode_hash_v2.py"

rule find_right_barcodes_ME:
    input: 
        "02_barcode_info/{sample}_ME_raw_barcode_count.txt"
    output: sum = "02_barcode_info/{sample}_ME.barcode_final_summary",
            map = "02_barcode_info/{sample}_ME.barcode_final_map",
            log = "02_barcode_info/{sample}_ME.barcode_log"
    script:
        "script/barcode_hash_v2.py"

## correct the barcode which barcode only have one mismatch
rule read1_barcode_correction_oligodT:
    input :
        "01_raw_fq_update/{sample}_adapter1RNA_oligodT_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1RNA_oligodT_L001_R2_001.fastq",
        "02_barcode_info/{sample}_oligodT.barcode_final_map"
    output :
        "03_corrected_fq/{sample}_oligodT_L001_R1_001.fastq",
        "03_corrected_fq/{sample}_oligodT_L001_R2_001.fastq"
    log: "00_log/{sample}_L001_R1_corrected.log"
    script:
        "script/fq_barcode_correction_R1.py"

rule read1_barcode_correction_randomN:
    input :
        "01_raw_fq_update/{sample}_adapter1RNA_randomN_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1RNA_randomN_L001_R2_001.fastq",
        "02_barcode_info/{sample}_randomN.barcode_final_map"
    output :
        "03_corrected_fq/{sample}_randomN_L001_R1_001.fastq",
        "03_corrected_fq/{sample}_randomN_L001_R2_001.fastq"
    log: "00_log/{sample}_L001_R1_corrected.log"
    script:
        "script/fq_barcode_correction_R1.py"

rule read1_barcode_correction_ME:
    input :
        "01_raw_fq_update/{sample}_adapter1ME_L001_R1_001.fastq",
        "01_raw_fq_update/{sample}_adapter1ME_L001_R2_001.fastq",
        "02_barcode_info/{sample}_ME.barcode_final_map"
    output :
        "03_corrected_fq/{sample}_ME_L001_R1_001.fastq",
        "03_corrected_fq/{sample}_ME_L001_R2_001.fastq"
    log: "00_log/{sample}_L001_R1_corrected.log"
    script:
        "script/fq_barcode_correction_R1.py"

## compress fastq files
rule compress_R1_oligodT:
    input  : "03_corrected_fq/{sample}_oligodT_L001_R1_001.fastq"
    output : "03_corrected_fq/{sample}_oligodT_L001_R1_001.fastq.gz"
    threads: 11
    shell:
        "pigz -p {threads} {input}"

rule compress_R2_oligodT:
    input  : "03_corrected_fq/{sample}_oligodT_L001_R2_001.fastq"
    output : "03_corrected_fq/{sample}_oligodT_L001_R2_001.fastq.gz"
    threads: 11
    shell:
        "pigz -p {threads} {input}"

rule compress_R1_randomN:
    input  : "03_corrected_fq/{sample}_randomN_L001_R1_001.fastq"
    output : "03_corrected_fq/{sample}_randomN_L001_R1_001.fastq.gz"
    threads: 11
    shell:
        """
        pigz -p {threads} {input}
        """

rule compress_R2_randomN:
    input  : "03_corrected_fq/{sample}_randomN_L001_R2_001.fastq"
    output : "03_corrected_fq/{sample}_randomN_L001_R2_001.fastq.gz"
    threads: 11
    shell:
        """
        pigz -p {threads} {input}
        """

rule compress_R1_ME:
    input  : "03_corrected_fq/{sample}_ME_L001_R1_001.fastq"
    output : "03_corrected_fq/{sample}_ME_L001_R1_001.fastq.gz"
    threads: 11
    shell:
        "pigz -p {threads} {input}"

rule compress_R2_ME:
    input  : "03_corrected_fq/{sample}_ME_L001_R2_001.fastq"
    output : "03_corrected_fq/{sample}_ME_L001_R2_001.fastq.gz"
    threads: 11
    shell:
        "pigz -p {threads} {input}"

## merge fastq files of randomN and OligoDT
rule merge_randomN_oligodT_R1:
    input  : 
        "03_corrected_fq/{sample}_randomN_L001_R1_001.fastq.gz",
        "03_corrected_fq/{sample}_oligodT_L001_R1_001.fastq.gz"
    output : 
        "03_corrected_fq/{sample}_all_L001_R1_001.fastq.gz"
    threads: 11
    shell:
        """
        cat {input[0]} {input[1]} > {output}
        """

rule merge_randomN_oligodT_R2:
    input  : 
        "03_corrected_fq/{sample}_randomN_L001_R2_001.fastq.gz",
        "03_corrected_fq/{sample}_oligodT_L001_R2_001.fastq.gz"
    output : 
        "03_corrected_fq/{sample}_all_L001_R2_001.fastq.gz"
    threads: 11
    shell:
        """
        cat {input[0]} {input[1]} > {output}
        """
